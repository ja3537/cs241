/*******************************************************************************
 * Joseph Adams
 *
 * cipher.c is a program used to encrypt and decrypt data from the standard
 * input. 
 *
 * The data is encrypted or decrypted using a linear congruential generator,
 * which will generate pseudo-random numbers given two parameters. It does
 * this according to the formula:
 * X_(n+1) = (aX_n + c) mod m
 * where c and m are specified by the user.
 * It then uses this number and performs the XOR operation with this number
 * mod 128 and the char from data. There are a few special instances
 * where the result is an unprintable character, but this will be
 * explained later.
 *
 * The data is to be passed through records of the form:
 * action,lgc_m,lcg_c,Data\n
 * where action is either 'e' or 'd' for encrypt or decrypt, lgc_m is 1-20
 * digits to be converted to an unsigned long and used at the lgc modulus.
 * lgc_c is another 1-20 digits used as the increment of our lgc.
*******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include "lcg.h"


char e;
/*char e is simply used to receive standard input using getchar().*/
char operation;
/*
 * operation is used to denote whether we are encrypting or decrypting.
 * If we are encrypting, operation will be 'e' and 'd' for decrypting.
 */
int status = 0;
/*
 * status is used to keep track of which part of the record we are reading
 * from. The first letter (e or d) is status 0, reading lcg_m is status 1,
 * lcg_c is status 2, and converting the data is status 3.
 */
int line_count = 1;
/*line_count is used to number records in the output.*/
int index1 = 0;
/*
 * As m and c are read from records, their digits are stored in array[],
 * and index1 is used to keep track of the index of this array.
 */
char array[21];
/*
 * array[] is used to store digits of m and c from records. When a comma is
 * reached, array is capped by the function is_comma(), and its contents
 * are converted to an unsigned long using strtoul().
 */
unsigned long m;
/* m is lcg_m and is used as the modulus for our LCG.*/
unsigned long c;
/*c is lcg_c and is used as the increment for our LCG.*/
char *ptr;
/*This pointer is used only for the strtoul() function.*/
struct LinearCongruentialGenerator lcg;
/*This is the LCG that will be made from the record.*/


/*******************************************************************************
 * found_error() is a very useful function that is used throughout this
 * program. It is used in the event that an error is found in the record or
 * during conversion. It prints an appropriate error message, resets some
 * variables, and skips to the end of the record line.
 *
 * found_error() does not return anything, but alters the global variables
 * status and index, which it sets back to zero. It also alters the array
 * used to receive data for m and c. The reason it resets these variables
 * is to get everything ready for the next record. found_error() stops
 * getting new characters from the input once it finds EOF or a newline
 * character.
*******************************************************************************/

void found_error()
{
  printf("Error\n");
  status = 0;
  index1 = 0;
  array[index1] = '\0';
  
  while(e != '\n' && e != EOF) e = getchar();
}

/*******************************************************************************
 * convert() is the most important function of the program. It is used only
 * for the part of the record with the data to be converted, and its job is
 * to convert this data, by either decrypting or encrypting as necessary.
 *
 * convert() does not return anything, but prints the converted character to
 * standard output. convert() takes the parameters e, which is the character
 * to be converted, and the pointer to our lcg, which it uses to encrypt or
 * decrypt e.
 *
 * convert() makes use of the local variables shift and xor. shift is simply
 * used to store the random value generated by our lcg (mod 128), and xor is
 * the result of the XOR operation between this and e.
 *
 * The printable ascii characters are between 32 and 126, inclusive. In the
 * encrypt portion, which starts with the check operation == 'e', we can see
 * how convert() handles situations where xor is not printable. If xor < 32,
 * convert() prints '*' followed by the character found by adding xor to '?'.
 * If xor is 127, which is the largest value it can be since it is mod 128,
 * convert() prints '*' followed by '!'. Other than these special conditions,
 * the encrypt portion of convert() simply prints xor as our encrypted
 * character. Of course, if xor is not a printable character, found_error()
 * is called.
 *
 * The decrypt portion of convert() is largely the encrypt portion in reverse,
 * with the possibility of a couple new errors. These errors exist in the 
 * section analagous to the '*'('?' + xor) part of our encryption. An error
 * could be that '*' is followed by an ascii character that is not in an
 * appropriate range, or we could have an xor that is not a printable
 * character. The local variable char d is used as a temporary variable to
 * test for errors in decryption.
*******************************************************************************/


void convert(char e, struct LinearCongruentialGenerator* lcg)
{
  unsigned long shift = getNextRandomValue(lcg)%128;
  unsigned char xor;
  xor = (e^shift)%128;
  if(operation == 'e')
    {
      if(xor < 32) printf("%c%c", '*','?' + xor);
      else if(xor == 127) printf("%c%c", '*','!');
      else if(xor == '*') printf("%c%c", '*','*');
      else if(xor > 31 && xor < 127) printf("%c", xor);
      else found_error();
    }
  else if(operation == 'd')
    {
      if(e == '*')
        {
          e = getchar();
          if(e == '*') printf("%c",xor);
          else if(e == '!') printf("%c", (char)(127^shift)%128);
          else if(e > '?' - 128 && e < '?' + 32)
            {
              char d = ((e - '?')^shift)%128;
              if(d > 31 && d < 127) printf("%c", d);
              else found_error();
            }
          else found_error();
        }
      else if(xor > 31 && xor < 127) printf("%c", xor);
      else found_error();
    }
}

/*******************************************************************************
 * is_comma() is used by the read_record() function whenever a comma is
 * encountered. In a record a comma denotes a shifting of status, between
 * reading digits for m to reading digits for c, for example.
 *
 * is_comma() does not return anything, but changes the global variables
 * status, array, and index. It's main job is to pass the contents of array[]
 * to m or c, depending on the status. It does this by first capping array[]
 * with the null character, then calling strtoul() to do the converstion.
 * After this, it prepares array[] for the next input by resetting index to
 * 0, and capping the first entry of array with the null character. It also
 * iterates the status.
*******************************************************************************/

          
void is_comma()
{
  array[index1] = '\0';
  if(status == 1) m = strtoul(array, &ptr, 10);
  else c = strtoul(array, &ptr, 10);
  index1 = 0;
  array[index1] = '\0';
  status = (status + 1)%4;
}

/*******************************************************************************
 * read_record() is used to read the record up until the data to be converted
 * is reached. It does not return anything, but affects global variables
 * line_count, operation, status, lcg, and array[].
 *
 * read_record() reads and records the conversion type in the first character
 * of the record, as well as calls found_error() in the event this first
 * character is not 'e' or 'd'.
 *
 * During status 1 and 2, it passes e to array[] while iterating index. If a
 * comma is reached during this time, is_comma() is called to pass the
 * contents of array[] to the appropriate variable.
 *
 * When status 1 and 2 are complete, status 3 is reached and read_record()
 * uses the makeLCG() function defined in lcg.h to make an lcg with m and c
 * and initialize the global variable lcg with this lcg. In the event the
 * values of m or c were not appropriate for any reason, makeLCG() is
 * designed to return an lcg with c = 0. read_record() checks to see if this
 * is the case, and if it is calls found_error().
*******************************************************************************/


void read_record()
{
  if(status == 0)
    {
      printf("%5d) ", line_count++);
      if(e == 'e' || e == 'd')
        {
          operation = e;
          status++;
        }
      else found_error();
    }
  else if(status == 1 || status == 2)
    {
      if(e >= '0' && e <= '9' && index1 < 20) array[index1++] = e;
      else if(e == ',')
        {
          is_comma();
          if(status == 3)
            {
              lcg = makeLCG(m,c);
              if(lcg.c == 0) found_error();
            }
        }
      else found_error();
    }
}

/*******************************************************************************
 * main() calls functions at appropriate times, depending on the status.
 *
 * main() influences the global variables e and status.
 *
 * It begins by initializing the global variable e using getchar(). The rest
 * of the program takes place inside a while loop because we do not want
 * this program to stop converting records until EOF is encountered. 
 *
 * If a '\n' is encountered, it means we have reached the end of a record, so
 * main() resets the status to 0. If e is convertible, main calls convert() to
 * convert it. If e is an unprintable character somehow, found_error() is
 * called. At the end of the while loop, the next character is pulled from
 * standard input using e = getchar();
*******************************************************************************/


int main(void)
{
  e = getchar();
  while(e != EOF)
    {
      if(status != 3) read_record();
      else
        {
          if(e == '\n')
            {
              status = 0;
              printf("\n");
              
            }
          else if(e > 31 && e < 127)
            {
              convert(e, &lcg);
            }
          else found_error();
        }
      if(c != EOF) e = getchar();
    }
  return 0;
}
      
              
          
      
          
  

  

  
